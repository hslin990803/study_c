// P.327 ~ chapter 15 도전! 프로그래밍2
/*
* 도전1
* 길이가 10인 배열을 선언하고 총 10개의 정수를 입력 받아서 홀수와 짝수를 구분 지어 출력하는 프로그램을 작성해 보자.
* 일단 홀수부터 출력하고 나서 짝수를 출력하도록 하자.
* 단, 10개의 정수는 main 함수 내에서 입력 받도록 하고, 
* 배열 내에 존재하는 홀수만 출력하는 함수와 배열 내에 존재하는 짝수만 출력하는 함수를
* 각각 정의해서 이 두 함수를 호출하는 방식으로 프로그램을 완성하자.
* 
* 실행의 예
* 총 10개의 숫자 입력
* 입력: 1
* 입력: 2
* 입력: 3
* 입력: 4
* 입력: 5
* 입력: 6
* 입력: 7
* 입력: 8
* 입력: 9
* 입력: 0
* 홀수 출력 : 1, 3, 5, 7, 9
* 짝수 출력 : 2, 4, 6, 8, 0
*/
//#include <stdio.h>
//void PrintOdd(int *arr) {
//	printf("홀수 출력 : ");
//	for (int i = 0; i < 10; i++) {
//		if (arr[i] % 2 != 0) {
//			printf("%d ", arr[i]);
//		}
//	}
//}
//
//void PrintEven(int* arr) {
//	printf("짝수 출력 : ");
//	for (int i = 0; i < 10; i++) {
//		if (arr[i] % 2 == 0) {
//			printf("%d ", arr[i]);
//		}
//	}
//}
//
//int main(void) {
//	int arr[10];
//
//	printf("총 10개의 숫자 입력\n");
//	for (int i = 0; i < 10; i++) {
//		printf("입력: ");
//		scanf("%d", &arr[i]);
//	}
//
//	PrintOdd(&arr);
//	printf("\n");
//	PrintEven(&arr);
//	printf("\n");
//
//	return 0;
//}

/*
* 도전2
* 프로그램 사용자로부터 10진수 형태로 정수를 하나 입력 받은 다음, 이를 2진수로 변환해서 출력하는 프로그램을 작성해 보자.
* 
* 실행의 예
* 10진수 정수 입력: 12
* 1100
* 
* 도전2의 해결을 위한 GUIDE
* 10진수를 2진수로 변환하는 방법을 모른다면, 먼저 그 방법부터 공부해야 한다.
* 그런데 대부분의 경우 변환 방법을 모르는 것이 아니라, 중학교 시절에 공부한 내용이라서 잘 기억이 나지 않는 것이다.
*/
//#include <stdio.h>
//void BinaryNumber(int num) {
//	if (num < 2)
//		printf("%d", num);
//	else {
//		BinaryNumber(num / 2);
//		printf("%d", num % 2);
//	}
//}
//int main(void) {
//	int num;
//
//	printf("10진수 정수 입력 : ");
//	scanf("%d", &num);
//
//	BinaryNumber(num);
//
//	return 0;
//}

/*
* 도전3
* 길이가 10인 배열을 선언하고 총 10개의 정수를 입력 받는다.
* 단, 입력 받은 숫자가 홀수이면 배열의 앞에서부터 채워나가고, 짝수이면 뒤에서부터 채워나가는 형식을 취하기로 하자.
* 따라서 사용자가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]을 입력했다면,
* 배열에는 [1, 3, 4, 5, 9, 10, 8, 6, 4, 2]의 순으로 저장이 되어야 한다.
* 
* 실행의 예
* 총 10개의 숫자 입력
* 입력: 1
* 입력: 1
* 입력: 4
* 입력: 4
* 입력: 4
* 입력: 4
* 입력: 3
* 입력: 3
* 입력: 2
* 입력: 2
* 배열 요소의 출력 : 1 1 3 3 2 2 4 4 4 4
*/
//#include <stdio.h>
//int main(void) {
//	int arr[10];
//	int num;
//	int front = 0;     // 앞쪽 인덱스
//	int rear = 9;      // 뒤쪽 인덱스
//
//	printf("총 10개의 숫자 입력 \n");
//	for (int i = 0; i < 10; i++) {
//		printf("입력: ");
//		scanf("%d", &num);
//
//		if (num % 2 != 0) {        // 홀수면 앞에서부터 채우기
//			arr[front++] = num;
//		}
//		else {                   // 짝수면 뒤에서부터 채우기
//			arr[rear--] = num;
//		}
//	}
//
//	printf("배열 요소의 출력 : ");
//	for (int i = 0; i < 10; i++)
//		printf("%d ", arr[i]);
//
//	return 0;
//}

/*
* 도전4
* 회문(Palindrome)은 앞으로 읽으나 뒤로 읽으나 차이가 없는 단어들을 뜻한다.
* 예를 들어서 level, bob과 같은 단어들은 회문에 속한다.
* 이에 우리는 인자로 전달되는 영단어가 회문인지 아닌지를 판단해서 그 결과를 출력하는 기능의 함수를 정의하고
* 이에 적절한 main 함수를 정의해보고자 한다.
* 단 구현의 편의를 위해서 대소문자까지 일치해야 회문으로 인정하기로 하겠다.
* (이는 어디까지나 구현의 편의를 고려한 제약사항일 뿐이다).
* 
* 실행의 예
* 문자열 입력 : noon
* 회문 입니다.
* 
* 도전4의 해결을 위한 GUIDE
* 입력된 문자열의 길이를 알아야 회문인지 아닌지를 판단할 수 있다.
* 따라서 문제의 해결을 위해서는 문자열의 길이를 계산해서 반환하는 함수도 정의해야 한다.
* 참고로 이러한 기능의 함수가 표준함수로 존재한다.
* 헤더파일 string.h에 선언되어 있는 strlen이란 이름의 함수이다.
* 이 함수에 대해서는 Chapter 21에서 소개한다.
*/
//#include <stdio.h>
//#include <string.h>
//int main(void) {
//	char str[100];
//	int length = 0;
//	int i = 0; 
//	int isPalindrome = 1;	// 참이라고 가정하고 시작
//
//	printf("문자열 입력 : ");
//	scanf("%s", str);
//
//	length = strlen(str);
//	
//	for (i = 0; i < length / 2; i++) {
//		if (str[i] != str[length - 1 - i]) {
//			isPalindrome = 0;
//			break;
//		}
//	}
//
//	if (isPalindrome)
//		printf("화문 입니다. \n");
//	else
//		printf("화문이 아닙니다. \n");
//
//	return 0;
//}

/*
* 도전5 (문제가 많이 길고, 그림과 코드까지 참고해야하므로 책 참고바람)
* 이번에는 정렬 알고리즘을 하나 소개하고, 이것을 이용한 프로그래밍 문제를 제시하고자 한다.
* 정렬이란 정의된 수서에 의해서 대상을 재배치하는 것을 의미한다.
* 예를 들어서 길이가 5인 배열에 정수 4, 3, 5, 1, 2가 저장되어 있다고 가정해보자.
* 이것을 오름차순(ascending order)으로 정렬하면 순서가 1, 2, 3, 4, 5로 재배치될 것이고,
* 내림차순(descending order)으로 정렬하면 순서가 5, 4, 3, 2, 1로 재배치될 것이다.
* 정렬에 대한 기본적인 개념은 누구나 가지고 있으므로 정렬에 대한 개념적인 소개는 이쯤에서 끝내기로 하겠다.
* 
* 정렬 알고리즘은 그 수가 다양하다.
* 그런데 여기서는 가장 쉬운 버블 정렬(bubble sort) 알고리즘을 소개하고자 한다.
* 버블 정렬이라는 이름은 정렬되는 과정이 마치 거품이 일어나는 모습과 유사하다고 해서 붙여진 이름이다.
* 그럼 그림을 통해서 버블 정렬의 기본 원리를 설명하겠다.
* 
* 위 그림의 배열에 저장된 데이터를 오름차순으로 정렬한다고 했을 때, 첫 번째로 해야 할 일은 가장 큰 값을 배열의 마지막으로 보내는 일이다.
* 이를 위해서 다음과 같은 순서의 연산을 진행하면 된다.
* 맨 앞에서부터 비교하여 가장 큰 값을 뒤로 밀어내는 작업이다.
* 
* 가장 큰 수를 배열의 마지막으로 보내는 것은 어렵지 않은 일이다.
* 앞에서부터 두 개의 숫자를 비교해가면서 큰 수를 뒤로 보내기만 하면 된다.(그림을 통해서 충분히 이해했을 것이다.)
* 
* 이제 두 번째 단계로 들어가자.
* 가장 큰 수가 배열의 마지막에 위치하였으므로 이것은 더 이상 건드릴 필요가 없다.
* 대신 그 다음으로 큰 수를 배열의 마지막 바로 앞부분으로 이동시켜야 한다.
* 다음 그림은 이에 필요한 과정을 설명한다.
* 
* 위 그림에서 보여주는 진행과정은 첫 번째 단계와 동일하다.
* 다만 차이점이 있다면, 배열의 마지막에 저장되어 있는 가장 큰 수를 건드리지 않았다는 점이다.
* 두 번째 단계까지 진행한 결과 네 개의 숫자 중에서 두 개의 숫자가 정렬되었다.
* 이제 나머지 두 개의 숫자를 정렬하기 위해서 마지막 단계를 진행하자.
* 
* 마지막 단계에서는 정렬되지 않은 두 개의 숫자를 비교해서 두 숫자 사이의 정렬을 진행하고 있다.
* 이로써 정렬이 완료되었다.
* 이제 우리가 해야 할 일은 지금까지 설명한 버블 정렬의 과정을 일반화하여 프로그램 코드로 옮기는 것이다.
* 몇 줄 안되므로 여러분이 한번 구현해보는 것도 좋은 공부가 될 것이다.
* 필자는 버블 정렬 알고리즘을 함수의 형태로 정의해서 여러분에게 보이겠다.
* 이는 그저 위에서 설명한 내용을 코드로 옮겨 놓은것에 불과하다.
*/

// P.331 BubbleSort.c
//#include <stdio.h>
//void BubbleSort(int ary[], int len);
//int main(void) {
//	int arr[4] = { 3,2,4,1 };
//	int i;
//
//	BubbleSort(arr, sizeof(arr) / sizeof(int));
//	for (i = 0; i < 4; i++)
//		printf("%d ", arr[i]);
//
//	printf("\n");
//
//	return 0;
//}
//
//void BubbleSort(int ary[], int len) {
//	int i, j;
//	int temp;
//
//	for (i = 0; i < len - 1; i++) {		// 오름차순 정렬
//		for (j = 0; j < (len - i) - 1; j++) {
//			if (ary[j] > ary[j + 1]) {
//				temp = ary[j];
//				ary[j] = ary[j + 1];
//				ary[j + 1] = temp;
//			}
//		}
//	}
//}

/*
* 자! 그럼 이제 문제를 제시하겠다.
* 배열에 저장되어 있는 요소들을 내림차순으로 정렬하는 함수를 정의하자(함수의 이름은 DesSort로 정의하자.).
* 그리고 이 함수를 호출하는 예제를 작성해보자.
* 프로그램의 흐름은 다음과 같이 구성을 하자.
* 일단 길이가 7인 int형 배열을 선언해서 프로그램 사용자로부터 7개의 정수를 입력 받도록 하자.
* 그리고 입력 받은 정수를 내림차순으로 정렬하기 위해서, 배열을 인자로 전달하면서 DesSort 함수를 호출하자.
* 그리고 마지막으로 제대로 정렬이 되었는지 확인하기 위해서 배열의 요소들을 순서대로 출력해보자.
* 
* 실행의 예
* 입력: 1
* 입력: 2
* 입력: 3
* 입력: 4
* 입력: 5
* 입력: 6
* 입력: 7
* 7 6 5 4 3 2 1
*/
//#include <stdio.h>
//void DesSort(int ary[], int len);
//int main(void) {
//	int arr[7];
//	int i;
//
//	for (i = 0; i < 7; i++) {
//		printf("입력: ");
//		scanf("%d", &arr[i]);
//	}
//
//	DesSort(arr, sizeof(arr) / sizeof(int));
//
//	for (i = 0; i < 7; i++)
//		printf("%d ", arr[i]);
//
//	printf("\n");
//
//	return 0;
//}
//
//void DesSort(int ary[], int len) {
//	int i, j;
//	int temp;
//
//	for (i = 0; i < len - 1; i++) {		// 내림차순 정렬
//		for (j = 0; j < (len - i) - 1; j++) {
//			if (ary[j] < ary[j + 1]) {
//				temp = ary[j];
//				ary[j] = ary[j + 1];
//				ary[j + 1] = temp;
//			}
//		}
//	}
//}