// P.79 ~ 데이터 표현방식의 이해

/*
* P.82 문제 04-1 [진법의 이해]
* 문제를 푸는 것은 이해에 많은 도움이 된다.
* 문제를 풀다 보면 본인이 이해한 것과 이해하지 못한것이 무엇인지 알게 되기 때문이다.
* 여기서 제시한 문제들은 다소 지루할 수 있다.
* 하지만 한번 정도는 풀어볼 만한 가치가 있는 문제들이다.
*/

/*
* 문제 1
* 10진수 8부터 20까지를 2진수와 16진수로 각각 표현해 보자.
* 참고로 이는 그림 04-2와 04-3을 참조하면 쉽게 해결이 가능한 문제이다.
*/

/*
* - 2진수
* 8 :	1000
* 9 :	1001
* 10 :	1010
* 11 :	1011
* 12 :	1100
* 13 :	1101
* 14 :	1110
* 15 :	1111
* 16 :	10000
* 17 :	10001
* 18 :	10010
* 19 :	10011
* 20 :	10100
* - 16진수
* 8 :	8
* 9 :	9
* 10 :	A
* 11 :	B
* 12 :	C
* 13 :	D
* 14 :	E
* 15 :	F
* 16 :	10
* 17 :	11
* 18 :	12
* 19 :	13
* 20 :	14
*/

/*
* 문제 2
* 10진수 5부터 18까지를 8진수로 표현해보자.
* 8진수에 대해서는 언급하지 않았지만 0부터 7까지 8개의 숫자만 사용하는 진법이라는 사실만 이해하면 충분히 해결할 수 있다.
* 참고로 필자는 이 문제를 통해서 여러분이 진법에 대한 기본적인 원리를 이해했는지를 묻고 있는 것이다.
*/

/*
* - 8진수
* 5 :	5
* 6 :	6
* 7 :	7
* 8 :	10
* 9 :	11
* 10 :	12
* 11 :	13
* 12 :	14
* 13 :	15
* 14 :	16
* 15 :	17
* 16 :	20
* 17 :	21
* 18 :	22
*/

/* 
* P.83 문제04-2 [데이터 표현의 이해]
* 데이터 표현방식에 대한 이해를 돕기 위해서 세가지 문제를 제시하겠다.
* 단순한 방법(연습장을 필요로 하는 방법)을 쓰든, 재치 있는 방법(수학적으로 계산하는 방법)을 쓰든, 반드시 해결하기바란다.
* 시간만 투자하면 누구나 해결할 수 있는 문제이다.
*/

/*
* 문제 1
* 1비트로 표현할 수 있는 데이터의 수는 0과 1 이렇게 두 개이다.
* 그리고 2비트가 표현할 수 있는 데이터의 수는 00, 01, 10, 11 이렇게 네 개이다.
* 그렇다면 4비트, 1바이트 그리고 4바이트로 표현할 수 있는 데이터의 수는 몇개인가?
* 
* - 정답 
* 4비트 : 16
* 1바이트 : 256
* 4바이트 : 4294967296
*/

/*
* 문제 2
* 1바이트 00000001은 10진수로 1이고, 1바이트 0000010은 10진수로 2이다.
* 그렇다면 다음 바이트들은 각각 10진수로 얼마가 되겠는가?
* 
* 00000001	:	1	
* 00000010	:	2
* 00000100	:	4
* 00001000	:	8
* 00010000	:	16
* 00100000	:	32
* 01000000	:	64
* 10000000	:	128
*/

/*
* 문제 3
* 문제 2에서 얻은 결과를 가지고, 다음 각각의 바이트들이 나타내는 값이 10진수로 얼마인지 계산해보자.
* 00010001	:	17
* 10100010	:	162	
* 11110111	:	247
*/

// P.85 Notation.c
//#include <stdio.h>
//int main(void) {
//	int num1 = 0xA7, num2 = 0x43;
//	int num3 = 032, num4 = 024;
//
//	printf("0xA7의 10진수 정수 값 : %d\n", num1);
//	printf("0x43의 10진수 정수 값 : %d\n", num2);
//	printf("032의 10진수 정수 값 : %d\n", num3);
//	printf("024의 10진수 정수 값 : %d\n", num4);
//
//	printf("%d-%d=%d \n", num1, num2, num1 - num2);
//	printf("%d+%d=%d \n", num3, num4, num3 + num4);
//
//	return 0;
//}

/*
* P.89 문제 04-3 [음의 정수 표현하기]
* 양의 정수와 음의 정수를 컴퓨터가 어떻게 2진수로 표현하는지 살펴보았다.
* 이를 기반으로 다음에서 제시하는 2진수가 10진수로 얼마인지 계산해보자.
* 단, 1바이트를 가지고 정수를 표현한다고 가정하자.
* 따라서 가장 왼쪽에 존재하는 비트는 부호비트가 된다.
*/

/*
* 문제 1
* 양의 정수 01001111과 00110011은 각각 10진수로 얼마인가?
* 
* - 정답
* 01001111	: 79
* 00110011	: 51
*/

/*
* 문제 2
* 음의 정수 10101001과 11110000은 각 10진수로 얼마인가?
* 
* - 정답
* 10101001	: -87
* 11110000	: -16
*/

// P.91 FloatError.c
//#include <stdio.h>
//int main(void) {
//	int i;
//	float num = 0.0;
//
//	for (i = 0; i < 100; i++)
//		num += 0.1;	// 이 연산을 총 100회 진행하게 됩니다.
//
//	printf("0.1을 100번 더한 결과 : %f\n", num);
//
//	return 0;
//}

// P.93 BitAndOperation.c
//#include <stdio.h>
//int main(void) {
//	int num1 = 15;	//	00000000 00000000 00000000 00001111
//	int num2 = 20;	//	00000000 00000000 00000000 00010100
//	int num3 = num1 & num2;		//num1과 num2의 비트단위 & 연산
//	
//	printf("AND 연산의 결과 : %d\n", num3);
//
//	return 0;
//}

// P.95 BitOrOperation.c
//#include <stdio.h>
//int main(void) {
//	int num1 = 15;	//	00000000 00000000 00000000 00001111
//	int num2 = 20;	//	00000000 00000000 00000000 00010100
//	int num3 = num1 | num2;		//num1과 num2의 비트단위 | 연산
//
//	printf("OR 연산의 결과 : %d\n", num3);
//
//	return 0;
//}

// P.96 BitXorOperation.c
//#include <stdio.h>
//int main(void) {
//	int num1 = 15;	//	00000000 00000000 00000000 00001111
//	int num2 = 20;	//	00000000 00000000 00000000 00010100
//	int num3 = num1 ^ num2;		//num1과 num2의 비트단위 ^ 연산
//
//	printf("XOR 연산의 결과 : %d\n", num3);
//
//	return 0;
//}

// P.97 BitNotOperation.c
//#include <stdio.h>
//int main(void) {
//	int num1 = 15;
//	int num2 = ~num1;
//	
//	printf("NOT 연산의 결과 : %d\n", num2);
//
//	return 0;
//}

// P.98 BitLeftShift.c
//#include <stdio.h>
//int main(void) {
//	int num = 15;	// 00000000 00000000 00000000 00001111
//	
//	int result1 = num << 1;	// num의 비트 열을 왼쪽으로 1칸씩 이동
//	int result2 = num << 2;	// num의 비트 열을 왼쪽으로 2칸씩 이동
//	int result3 = num << 3;	// num의 비트 열을 왼쪽으로 3칸씩 이동
//
//	printf("1칸 이동 결과 : %d \n", result1);
//	printf("2칸 이동 결과 : %d \n", result2);
//	printf("3칸 이동 결과 : %d \n", result3);
//
//	return 0;
//}

// P.100 BitRightShift.c
//#include <stdio.h>
//int main(void) {
//	int num = -16;	//	11111111 11111111 11111111 11110000
//	
//	printf("2칸 오른쪽 이동의 결과 : %d \n", num >> 2);
//	printf("3칸 오른쪽 이동의 결과 : %d \n", num >> 3);
//
//	return 0;
//}

/*
* P.100 문제 04-4 [비트연산의 이해]
*/

/*
* 문제 1
* 입력 받은 정수 값의 부호를 바꿔서 출력하는 프로그램을 작성해보자.
* 예를 들어서 -3이 입력되면 3이 출력되어야 하고, 5가 입력되면 -5가 출력되어야 한다.
* 단! 반드시 이번 Chapter에서 소개한 비트 연산자를 이용해서 구현해야 한다.
*/

//#include <stdio.h>
//int main(void) {
//	int num;
//
//	printf("정수 입력 : ");
//	scanf("%d", &num);
//
//	if (num == -3 || num == 5) {
//		num = ~num + 1;
//	}
//	printf("%d", num);
//
//	return 0;
//}

/*
* 문제 2
* 다음 연산의 결과를 출력하는 프로그램을 작성해보자.
* 단, * 연산자와 / 연산자를 사용하지 않고 구현해야 한다.
* 3X8%4
* 물론 중간과정을 생략하거나 적절히 암산하지 않고, 
* 반드시 곱셈에 대응하는 연산과 나눗셈에 대응하는 연산을 거쳐서 해결해야 한다.
*/

//#include <stdio.h>
//int main(void) {
//	int num = 3;
//	num = num << 3;
//	num = num >> 2;
//
//	printf("3X8%4=%d", num);
//
//	return 0;
//}